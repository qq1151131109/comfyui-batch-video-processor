"""
ÊâπÈáèËßÜÈ¢ëÂ§ÑÁêÜÂ∑•ÂÖ∑ÂáΩÊï∞
"""

import os
import glob
import tempfile
import zipfile
import shutil
from datetime import datetime
from pathlib import Path
from typing import List, Optional, Tuple
import ffmpeg
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import folder_paths


def get_video_duration(video_path: str) -> float:
    """Ëé∑ÂèñËßÜÈ¢ëÊó∂ÈïøÔºàÁßíÔºâ"""
    try:
        probe = ffmpeg.probe(video_path)
        duration = float(probe['streams'][0]['duration'])
        return duration
    except Exception as e:
        print(f"Ëé∑ÂèñËßÜÈ¢ëÊó∂ÈïøÂ§±Ë¥• {video_path}: {e}")
        return 0


def get_video_info(video_path: str) -> dict:
    """Ëé∑ÂèñËßÜÈ¢ëËØ¶ÁªÜ‰ø°ÊÅØ"""
    try:
        probe = ffmpeg.probe(video_path)
        video_stream = next(s for s in probe['streams'] if s['codec_type'] == 'video')
        
        return {
            'duration': float(video_stream.get('duration', 0)),
            'width': int(video_stream['width']),
            'height': int(video_stream['height']),
            'fps': eval(video_stream.get('r_frame_rate', '30/1')),
            'codec': video_stream.get('codec_name', 'unknown'),
            'file_size': os.path.getsize(video_path)
        }
    except Exception as e:
        print(f"Ëé∑ÂèñËßÜÈ¢ë‰ø°ÊÅØÂ§±Ë¥• {video_path}: {e}")
        return {}


def scan_video_files(folder_path: str, extensions: List[str] = None, recursive: bool = True) -> List[str]:
    """Êâ´ÊèèÊñá‰ª∂Â§π‰∏≠ÁöÑËßÜÈ¢ëÊñá‰ª∂
    
    Args:
        folder_path: Ë¶ÅÊâ´ÊèèÁöÑÊñá‰ª∂Â§πË∑ØÂæÑ
        extensions: ËßÜÈ¢ëÊñá‰ª∂Êâ©Â±ïÂêçÂàóË°®
        recursive: ÊòØÂê¶ÈÄíÂΩíÊâ´ÊèèÂ≠êÁõÆÂΩïÔºåÈªòËÆ§True
    """
    if extensions is None:
        extensions = ['mp4', 'avi', 'mov', 'mkv', 'flv', 'wmv', 'm4v']
    
    video_files = []
    
    if recursive:
        # ÈÄíÂΩíÊâ´ÊèèÊâÄÊúâÂ≠êÁõÆÂΩï
        for ext in extensions:
            # ÈÄíÂΩíÊ®°ÂºèÔºö‰ΩøÁî® ** ÈÄöÈÖçÁ¨¶
            pattern = os.path.join(folder_path, "**", f"*.{ext}")
            video_files.extend(glob.glob(pattern, recursive=True))
            # ÂêåÊó∂ÊîØÊåÅÂ§ßÂÜôÊâ©Â±ïÂêç
            pattern = os.path.join(folder_path, "**", f"*.{ext.upper()}")
            video_files.extend(glob.glob(pattern, recursive=True))
    else:
        # ÈùûÈÄíÂΩíÊ®°ÂºèÔºöÂè™Êâ´ÊèèÂΩìÂâçÁõÆÂΩï
        for ext in extensions:
            pattern = os.path.join(folder_path, f"*.{ext}")
            video_files.extend(glob.glob(pattern))
            # ÂêåÊó∂ÊîØÊåÅÂ§ßÂÜôÊâ©Â±ïÂêç
            pattern = os.path.join(folder_path, f"*.{ext.upper()}")
            video_files.extend(glob.glob(pattern))
    
    return sorted(video_files)


def scan_media_files(folder_path: str, file_types: List[str] = None, recursive: bool = True) -> dict:
    """Êâ´ÊèèÊñá‰ª∂Â§π‰∏≠ÁöÑÂ§öÂ™í‰ΩìÊñá‰ª∂
    
    Args:
        folder_path: Ë¶ÅÊâ´ÊèèÁöÑÊñá‰ª∂Â§πË∑ØÂæÑ
        file_types: Ë¶ÅÊâ´ÊèèÁöÑÊñá‰ª∂Á±ªÂûãÂàóË°® ['video', 'audio', 'image']
        recursive: ÊòØÂê¶ÈÄíÂΩíÊâ´ÊèèÂ≠êÁõÆÂΩïÔºåÈªòËÆ§True
    """
    if file_types is None:
        file_types = ['video', 'audio', 'image']
    
    # ÂÆö‰πâÂêÑÁßçÊñá‰ª∂Á±ªÂûãÁöÑÊâ©Â±ïÂêç
    extensions = {
        'video': ['mp4', 'avi', 'mov', 'mkv', 'flv', 'wmv', 'm4v', 'webm'],
        'audio': ['mp3', 'wav', 'aac', 'flac', 'ogg', 'm4a', 'wma'],
        'image': ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp']
    }
    
    result = {}
    total_files = []
    
    for file_type in file_types:
        if file_type not in extensions:
            continue
            
        files = []
        for ext in extensions[file_type]:
            if recursive:
                # ÈÄíÂΩíÊ®°ÂºèÔºö‰ΩøÁî® ** ÈÄöÈÖçÁ¨¶
                pattern = os.path.join(folder_path, "**", f"*.{ext}")
                files.extend(glob.glob(pattern, recursive=True))
                # ÂêåÊó∂ÊîØÊåÅÂ§ßÂÜôÊâ©Â±ïÂêç
                pattern = os.path.join(folder_path, "**", f"*.{ext.upper()}")
                files.extend(glob.glob(pattern, recursive=True))
            else:
                # ÈùûÈÄíÂΩíÊ®°ÂºèÔºöÂè™Êâ´ÊèèÂΩìÂâçÁõÆÂΩï
                pattern = os.path.join(folder_path, f"*.{ext}")
                files.extend(glob.glob(pattern))
                # ÂêåÊó∂ÊîØÊåÅÂ§ßÂÜôÊâ©Â±ïÂêç
                pattern = os.path.join(folder_path, f"*.{ext.upper()}")
                files.extend(glob.glob(pattern))
        
        result[file_type] = sorted(files)
        total_files.extend(files)
    
    result['all'] = sorted(total_files)
    return result


def create_batch_folder(base_dir: str, session_name: str) -> str:
    """ÂàõÂª∫ÊâπÈáèÂ§ÑÁêÜÊñá‰ª∂Â§π"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    folder_name = f"{timestamp}_{session_name}"
    batch_folder = os.path.join(base_dir, "batch_uploads", folder_name)
    os.makedirs(batch_folder, exist_ok=True)
    return batch_folder


def create_output_folder(base_dir: str, session_name: str) -> str:
    """ÂàõÂª∫ËæìÂá∫Êñá‰ª∂Â§π"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    folder_name = f"{timestamp}_{session_name}_processed"
    output_folder = os.path.join(base_dir, "processed_batches", folder_name)
    os.makedirs(output_folder, exist_ok=True)
    return output_folder


def prepare_end_video(end_video_path: str, target_width: int, target_height: int, temp_dir: str) -> str:
    """È¢ÑÂ§ÑÁêÜÁªìÂ∞æËßÜÈ¢ëÔºåÁªü‰∏ÄÁºñÁ†ÅÂèÇÊï∞"""
    try:
        prepared_path = os.path.join(temp_dir, "prepared_end.mp4")
        
        end_input_stream = ffmpeg.input(end_video_path)
        end_video_stream = (end_input_stream.video
                           .filter('scale', target_width, target_height, flags='lanczos')
                           .filter('setsar', '1'))
        end_audio_stream = end_input_stream.audio
        
        (
            ffmpeg
            .output(
                end_video_stream,
                end_audio_stream,
                prepared_path,
                vcodec='libx264',
                preset='fast',
                **{'profile:v': 'main'},
                r=30,
                acodec='aac',
                ar=44100,
                ac=2
            )
            .overwrite_output()
            .run(quiet=True)
        )
        
        return prepared_path
    except Exception as e:
        print(f"È¢ÑÂ§ÑÁêÜÁªìÂ∞æËßÜÈ¢ëÂ§±Ë¥•: {e}")
        return end_video_path


def cut_single_segment_with_end(video_path: str, start_time: float, end_time: float, 
                               output_path: str, prepared_end_path: str, end_duration: float) -> bool:
    """ÂàáÂàÜÂçï‰∏™ËßÜÈ¢ëÁâáÊÆµÂπ∂Ê∑ªÂä†ÁªìÂ∞æËßÜÈ¢ë"""
    try:
        # Ëé∑Âèñ‰∏ªËßÜÈ¢ë‰ø°ÊÅØ
        main_probe = ffmpeg.probe(video_path)
        main_video_stream = next(s for s in main_probe['streams'] if s['codec_type'] == 'video')
        main_width = int(main_video_stream['width'])
        main_height = int(main_video_stream['height'])
        
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_main = os.path.join(temp_dir, "temp_main.mp4")
            
            # ÂàáÂàÜ‰∏ªËßÜÈ¢ë
            input_stream = ffmpeg.input(video_path, ss=start_time, t=end_time-start_time, 
                                       **{'fflags': '+ignidx+igndts'})
            video_stream = (input_stream.video
                           .filter('scale', main_width, main_height, flags='lanczos')
                           .filter('setsar', '1'))
            audio_stream = input_stream.audio
            
            (
                ffmpeg
                .output(
                    video_stream,
                    audio_stream,
                    temp_main,
                    vcodec='libx264',
                    preset='fast',
                    **{'profile:v': 'main'},
                    r=30,
                    acodec='aac',
                    ar=44100,
                    ac=2,
                    **{'fflags': '+ignidx+igndts'}
                )
                .overwrite_output()
                .run(quiet=True)
            )
            
            # ÂêàÂπ∂‰∏ªËßÜÈ¢ëÂíåÁªìÂ∞æËßÜÈ¢ë
            main_input = ffmpeg.input(temp_main)
            end_input = ffmpeg.input(prepared_end_path)
            
            (
                ffmpeg
                .filter([main_input.video, main_input.audio, end_input.video, end_input.audio], 
                       'concat', n=2, v=1, a=1)
                .output(output_path, vcodec='libx264', acodec='aac')
                .overwrite_output()
                .run(quiet=True)
            )
        
        return True
    except Exception as e:
        print(f"Â§ÑÁêÜËßÜÈ¢ëÁâáÊÆµÂ§±Ë¥• {video_path}: {e}")
        return False


def create_download_archive(source_folder: str, archive_name: str, archive_format: str = "zip", 
                          include_metadata: bool = True) -> Tuple[str, int, int]:
    """ÂàõÂª∫‰∏ãËΩΩÂéãÁº©ÂåÖ"""
    try:
        output_dir = folder_paths.get_output_directory()
        # Áõ¥Êé•‰ΩøÁî®outputÁõÆÂΩïÔºåÈÅøÂÖçÂ≠êÁõÆÂΩïÈóÆÈ¢ò
        print(f"üêõ Ë∞ÉËØï: output_dir = {output_dir}")
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S") 
        # ‰ΩøÁî®Ëã±ÊñáÊñá‰ª∂ÂêçÔºåÈÅøÂÖçÁºñÁ†ÅÈóÆÈ¢ò
        safe_archive_name = "batch_result" if any(ord(c) > 127 for c in archive_name) else archive_name
        archive_path = os.path.join(output_dir, f"{safe_archive_name}_{timestamp}.{archive_format}")
        print(f"üêõ Ë∞ÉËØï: archive_path = {archive_path}")
        
        file_count = 0
        total_size = 0
        
        if archive_format == "zip":
            with zipfile.ZipFile(archive_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for root, dirs, files in os.walk(source_folder):
                    for file in files:
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, source_folder)
                        zipf.write(file_path, arcname)
                        file_count += 1
                        total_size += os.path.getsize(file_path)
                
                # Ê∑ªÂä†ÂÖÉÊï∞ÊçÆÊñá‰ª∂
                if include_metadata:
                    metadata = generate_processing_metadata(source_folder)
                    zipf.writestr("processing_info.json", metadata)
        
        return archive_path, file_count, total_size
    except Exception as e:
        print(f"ÂàõÂª∫ÂéãÁº©ÂåÖÂ§±Ë¥•: {e}")
        return "", 0, 0


def generate_processing_metadata(folder_path: str) -> str:
    """ÁîüÊàêÂ§ÑÁêÜÂÖÉÊï∞ÊçÆ"""
    import json
    
    metadata = {
        "processing_time": datetime.now().isoformat(),
        "folder_path": folder_path,
        "file_count": len(os.listdir(folder_path)),
        "total_size": sum(os.path.getsize(os.path.join(folder_path, f)) 
                         for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))),
        "version": "1.0"
    }
    
    return json.dumps(metadata, indent=2, ensure_ascii=False)


def clean_old_batches(base_dir: str, days_to_keep: int = 7) -> List[str]:
    """Ê∏ÖÁêÜÊóßÁöÑÊâπÂ§ÑÁêÜÊñá‰ª∂"""
    import time
    
    cleaned_folders = []
    current_time = time.time()
    cutoff_time = current_time - (days_to_keep * 24 * 60 * 60)
    
    for folder_type in ["batch_uploads", "processed_batches"]:
        folder_path = os.path.join(base_dir, folder_type)
        if not os.path.exists(folder_path):
            continue
            
        for item in os.listdir(folder_path):
            item_path = os.path.join(folder_path, item)
            if os.path.isdir(item_path):
                if os.path.getctime(item_path) < cutoff_time:
                    try:
                        shutil.rmtree(item_path)
                        cleaned_folders.append(item_path)
                    except Exception as e:
                        print(f"Ê∏ÖÁêÜÊñá‰ª∂Â§πÂ§±Ë¥• {item_path}: {e}")
    
    return cleaned_folders


def format_file_size(size_bytes: int) -> str:
    """Ê†ºÂºèÂåñÊñá‰ª∂Â§ßÂ∞èÊòæÁ§∫"""
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f} KB"
    elif size_bytes < 1024 * 1024 * 1024:
        return f"{size_bytes / (1024 * 1024):.1f} MB"
    else:
        return f"{size_bytes / (1024 * 1024 * 1024):.1f} GB"